// https://observablehq.com/@kaimdx/rampvis-idiom-gmap@877
import define1 from "./02a4320e0e6cbe73@363.js";

export default function define(runtime, observer) {
  const main = runtime.module();
  const fileAttachments = new Map([["gmap-location-as-cluster-crop.png",new URL("./files/9032ef3f85576dbed90d78cf63cbdae4f8f0b8f28f42dbfdb3d9a127e0a0f2335276771d7f61b56d6a5ef52fd5e2bde9cc82acc6ccea5774239b7cc433ba4e15",import.meta.url)],["ConnectedNodeAsCluster_50_zoom_in.png",new URL("./files/4d06fc374b09d92d26217382e0e9285a964f002f647381cdf40f67795c3e38a062b3ca91853446e6b49165996caab7fbe63eb741d512be62de047d31f0503d11",import.meta.url)],["ConnectedNodeAsCluster_50_1000px.png",new URL("./files/ab515fdfa87c18dbe238211e139d72ac8184a11e91a6308271fdf06fc93ac03ce491c54d9cf50943c4455d3b9f150fc7b6ce9cda422023d1a175c1d2c21f5ec0",import.meta.url)]]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], function(md){return(
md`# RAMPVIS : GMap`
)});
  main.variable(observer()).define(["ui","htl"], function(ui,htl)
{

  // If this page is outside of Observable, set the default styles to approximate
  // the appearance of the Observable Look and Feel.
  if (ui === "custom") {
    return htl.html`<style>@import url('https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;700&display=swap');

  body {
     font-family: 'Source Serif Pro', serif;
     font-weight: 400;
     line-height: 1.6;
     color: #333;
     padding-left: 2em;
     padding-right: 2em;
  }

  p,div,ul,ol,li {
    max-width: 640px;
  }

  form,table,tr,td,th {
    font-family: sans-serif !important;
    font-size: 9pt !important;
    color: #333;
  }

  table {
    margin-top:0.5em !important;
    margin-bottom:0.5em !important;
  }

  .observablehq .observablehq--inspect {
    display: none;
  }
  </style>

  <pre style="font-size:8pt; font-style: italic;"><b>Note:</b> This is an archived version of an Observable Notebook supplement for the RAMPVIS PhilTransA submission titled: </br>"Visualization for Epidemiological Modelling: Challenges, Solutions, Reflections & Recommendations"</br>For the live version, see here: <a href="https://observablehq.com/@kaimdx/rampvis-idiom-gmap">https://observablehq.com/@kaimdx/rampvis-idiom-gmap</a></pre>`;

  } else {
    return htl.html`<pre style="font-size:8pt; font-style: italic;"><b>Note:</b> This is a live version of the Observable Notebook supplement for the RAMPVIS PhilTransA submission titled </br>"Visualization for Epidemiological Modelling: Challenges, Solutions, Reflections & Recommendations"</pre>`;
  }
}
);
  main.variable(observer()).define(["md"], function(md){return(
md`---
## 1. TASK & USERS - User Story`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`* As an epidemiological model builder
* I would like to know
  * if there is any error in the simulation model
  * how the parameters affect the output
  * the effect of different isolation policy options
* so that I can 
  *  detect and fix any errors in the simulation code
  *  choose parameter values that lead to outputs that match reality
  *  develop an intuitive feel and understanding of the model dynamics 
  *  understand the balance between the loss of freedom and the size of the infected population for different isolation policies
  *  guide the quantitative measures we extract from the simulations
  *  conceptualise control measures that tackle key features of the dynamics`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---

## 2. DATA`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`The data used for the GMap visualisation is generated by the simulation model (written in Java), which is available on Github https://github.com/ScottishCovidResponse/Contact-Tracing-Model.

The dataset used to generate the GMap visualisations below are available on GitHub: https://github.com/jeewanhyongju/InfectionMap-Visualization`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---

## 3. GMap`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Traditional graph visualization methods often fail to capture the underlying structural information, clustering, and neighbourhoods in the network.

**GMap** provides a way to overcome some of these shortcomings with the help of the geographic map metaphor: nodes are grouped with coloured backgrounsd, similar to regions on a geographical map.

**GMap** has the added advantage of familiarity comparing to other graph visualisation methods, as most people are very familiar with maps and even enjoy carefully examining them.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---
## 4. ORIGIN & CONTEXT`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`**GMap** was originally introduced by [Gansner et al (2010)](https://doi.org/10.1109/PACIFICVIS.2010.5429590) as a way to show clusters in a graph. 

**GMap** was later evaluated in a user study by [Jianu et al (2014)](https://doi.org/10.1109/TVCG.2014.2315995) together with other set visualisation methods including BubbleSet and LineSet. It was found that the GMap can improve memorability comparing to the alternatives. For group membership tasks, GMap can outperform alternatives if its visual design is slightly changed by connecting separate areas that belong to the same group. During the user study, the authors manually edited the images produced by the GMap to achieve this result. We did not implement this feature in the project because of time and resource constraints.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`___

## 5. EXAMPLES`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`This is an example showing [the relationships among the musicians and groups](http://gmap.cs.arizona.edu/description) using GMap.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---
## 6. DESCRIPTION & USE`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Choosing the data attribute or dimension to cluster is one of the main design choices when creating GMaps. After discussion with the epidemiologists, it was identified that there are two candidates: 
- the location of a person when he/she is infected (such as school or shops)
- the infection chain a person belongs to: an infection chain starts with one infected person at time t0. This person infects others, who in turn infect more people. All the people who have the common source infection form a chain.

The image below shows part of the GMap where the colour indicates the location of where a person is infected (such as school or shop). Each numbered node is a person, and two are connected if one infects the other (the infection is directional but this is not shown in the visualisation). The person with a red number and a circle is the 'source' of each infection chain or cluster.

Below we have a GMap of coloured areas that types of place at which infections occur.
The node background colours shows the type of location at which each person is infected.
Two people have the same background colour if they are infected at the same (type of) place.
All the neighbouring persons with the same infection place type form a cluster.
There are 10 different types of locations including restaurant, school, shop, office, etc.`
)});
  main.variable(observer()).define(["FileAttachment"], async function(FileAttachment){return(
await FileAttachment("gmap-location-as-cluster-crop.png").image({width:800})
)});
  main.variable(observer()).define(["md"], function(md){return(
md`The other alternative is to use the infection chain as the cluster, i.e., all the people in the same infection chain has the same background colour. In the image below, the node shape is used to show the location information as discussed earlier (circle is restaurant, square is school, etc.).
This is a GMap of coloured areas that represent infection networks.`
)});
  main.variable(observer()).define(["FileAttachment"], async function(FileAttachment){return(
await FileAttachment("ConnectedNodeAsCluster_50_zoom_in.png").image({width:800})
)});
  main.variable(observer()).define(["md"], function(md){return(
md`The size of the clusters gives the users some idea of how many people are infected and how fast the spread is (a larger cluster usually means a faster spread). The epidemiological modellers can mentally compare the visualisation with what they expected to identify any obvious issues in the model. Comparing visualisations from different isolation policies allow the users to see the difference in policy impact and their dynamics.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---
## 7. REFLECTION`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`### 7.0 Reflective Discussion  `
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Because of the 'emergency' nature of the project, there was no time for the usual user requirement analysis or design/brainstorming session to generate design ideas. The team had to start working on the data and generating visualisation straightaway. Usually this is not recommended, but it seemed to work well in this particular case. The requirement and design work seem to become part of the visualisation creation: we learn more about the data and user requirements as we create/test more visualisations.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`The GMap is part of the contact tracing team effort. It is designed to work with statistical analysis and other visualisations (such as dynamic node-link graph visualisation) efforts that were ongoing in parallel at the same time. The results from these efforts complement each other and provide multiple perspectives of the target problem.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`### 7.1 What Worked`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`The epidemiologists found the second visualisation, which uses the infection chain for clustering, most useful. 

As the coloured cluster background is visually dominant, choosing which data attribute to use is equivalent to selecting the attribute that is most important for the analysis because other attributes will not be as prominent if represented visually. This requires the designers and users to identify the most important data attribute, which is a useful exercise in understanding the visualisation requirements. 

The other reason that the first visualisation, which uses location type for clustering, is less favourable is that it has more and smaller clusters, which is less informative for the users. Knowing that there are many small clusters can be potentially useful, but usually it is the larger clusters that are of more interest to the users. 

Another disadvantage of having many small clusters is the increased visual complexity, which usually has a negative impact on visual analysis.

Finally, having many small clusters makes it less feasible to use other visual channels to represent additional data attributes. For example, the node shape is more likely to interfere with cluster boundary when the cluster is small.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`### 7.2 What Didn't Work`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Because the model tries to simulate the population within a fairly large region, there can be easily thousands, tens of thousands, or even more people in the infection network. This is close to the limit of how big a graph GMap can visualise, if not over. The image below shows the 50 largest infection chains from the simulation results. It is difficult to see the details of each cluster, even when many smaller clusters are excluded.`
)});
  main.variable(observer()).define(["FileAttachment"], async function(FileAttachment){return(
await FileAttachment("ConnectedNodeAsCluster_50_1000px.png").image({width:800})
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Another challenge is that the computation of the GMap layout can be quite slow, especially for large graphs. This will make it not suitable for interactive visualisation, even if a JavaScript version existed.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`### 7.3 Recommendations & Opportunities`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`Choosing the data attribute for clustering can be a useful and important exercise, as it forces the users and design to identify the most important data attribute, which is not always clear when a project starts, even for the users.

There is a chance that the most important data attribute leads to a GMap visualisation with many small clusters (luckily not in this case). The increased visual complexity is likely to hinder visual analysis. It will be an interesting research challenge to adapt GMap for this situation. 

There are also scalability issues for both visual complexity and response time. Multi-level/scale graph visualisation techniques can be potentially applied to improve the effectiveness of GMaps when the graph is very large, and more algorithmic improvement is needed to make GMap feasible for interactive visualisation.`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`### 7.4 Who Was Involved?
`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`**Kai Xu**, **Cagatay Turkay**, **Sibylle Mohr**, **Louise Matthews** and **Daniel Archambault**`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---

## 8. REFERENCES`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`**Gansner, E.R., Hu, Y. and Kobourov, S. (2010).<br/>**
_GMap: Visualizing graphs and clusters as maps_<br/>
2010 IEEE Pacific Visualization Symposium (PacificVis), pp. 201–208.<br/>
https://doi.org/10.1109/PACIFICVIS.2010.5429590`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`**Jianu, R. et al. (2014).<br/>**
_How to Display Group Information on Node-Link Diagrams: An Evaluation_<br/>
IEEE Transactions on Visualization and Computer Graphics, 20(11), pp. 1530–1541.<br/>
https://doi.org/10.1109/TVCG.2014.2315995`
)});
  main.variable(observer()).define(["md"], function(md){return(
md`---`
)});
  const child1 = runtime.module(define1);
  main.import("ui", child1);
  return main;
}
